// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
  // Further reading:
  // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
  // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
  url      = env("DATABASE_URL")
}

enum TransactionSide {
  BUY
  SELL
}

model Transaction {
  id            String          @id @default(cuid())
  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String
  date          DateTime
  symbol        String
  side          TransactionSide
  quantity      Float
  price         Float
  priceCurrency Currency        @default(USD)
  fee           Float?
  feeCurrency   Currency? // optional; if null, treat as priceCurrency
  note          String?
  createdAt     DateTime        @default(now())

  @@index([userId, date])
  @@index([userId, symbol])
}

// Better Auth Account schema
model Account {
  id                    String    @id @default(cuid())
  userId                String
  accountId             String    @map("providerAccountId") // Map to Better Auth's expected field
  providerId            String    @map("provider") // Map to Better Auth's expected field
  refreshToken          String?   @map("refresh_token") // @db.Text
  accessToken           String?   @map("access_token") // @db.Text
  accessTokenExpiresAt  DateTime? @map("expires_at") // Changed from Int to DateTime
  idToken               String?   @map("id_token") // @db.Text
  scope                 String?
  password              String? // For email/password auth
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @default(now()) @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@map("Account")
}

model Session {
  id              String   @id @default(cuid())
  token           String   @unique @map("sessionToken") // Map to Better Auth's expected field
  userId          String
  expiresAt       DateTime @map("expires") // Map to Better Auth's expected field
  ipAddress       String?
  userAgent       String?
  impersonatedBy  String? // Admin plugin: ID of admin impersonating this session
  createdAt       DateTime @default(now())
  updatedAt       DateTime @default(now()) @updatedAt
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("Session")
}

model User {
  id                     String             @id @default(cuid())
  name                   String?
  email                  String?            @unique
  emailVerified          Boolean            @default(false)
  emailVerifiedAt        DateTime?
  image                  String?
  passwordHash           String?
  twoFactorEnabled       Boolean            @default(false)
  role                   String             @default("user") // Admin plugin: user role
  banned                 Boolean            @default(false) // Admin plugin: ban status
  banReason              String? // Admin plugin: reason for ban
  banExpires             DateTime? // Admin plugin: when ban expires
  theme                  Theme              @default(LIGHT)
  currency               Currency           @default(USD)
  createdAt              DateTime           @default(now())
  updatedAt              DateTime           @updatedAt
  accounts               Account[]
  sessions               Session[]
  transactions           Transaction[]
  watchlist              WatchlistItem[]
  emailChangeTokens      EmailChangeToken[]
  goals                  Goal[]
  twoFactor              TwoFactor[]
}

// Better Auth Two-Factor Authentication
model TwoFactor {
  id          String  @id @default(cuid())
  userId      String  @unique
  secret      String
  backupCodes String
  user        User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("twoFactor")
}

// Better Auth verification model
model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([identifier, value])
  @@map("verification")
}

// Legacy NextAuth verification tokens (for password reset, email change)
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("VerificationToken")
}

model EmailChangeToken {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  newEmail  String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
}

enum Theme {
  LIGHT
  DARK
}

enum Currency {
  EUR
  USD
  GBP
  HKD
  CHF
  RUB
}

model WatchlistItem {
  id            String   @id @default(cuid())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String
  symbol        String
  displaySymbol String?
  description   String?
  type          String?
  currency      Currency @default(USD)
  createdAt     DateTime @default(now())
  starred       Boolean  @default(false)

  @@unique([userId, symbol])
  @@index([userId])
  @@index([symbol])
}

// Store latest FX rates by base->quote with timestamp
model FxRate {
  id        String   @id @default(cuid())
  base      Currency
  quote     Currency
  rate      Float
  fetchedAt DateTime @default(now())

  @@unique([base, quote])
  @@index([fetchedAt])
}

/// Personal financial goals for a user (e.g., buy a house, retirement)
model Goal {
  id             String    @id @default(cuid())
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  title          String
  targetAmount   Float
  targetCurrency Currency  @default(USD)
  targetDate     DateTime?
  note           String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([userId])
  @@index([targetDate])
}
